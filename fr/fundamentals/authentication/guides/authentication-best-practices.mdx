---
title: Bonnes pratiques
---

import { Button } from "/snippets/fr/button.mdx";

Vos clÃ©s et jetons dâ€™API doivent Ãªtre protÃ©gÃ©s avec la plus grande vigilance.Â 

Ces identifiants sont directement liÃ©s Ã  votre [application dÃ©veloppeur](/fr/resources/fundamentals/developer-apps) ainsi quâ€™aux comptes X qui vous ont autorisÃ© Ã  effectuer des requÃªtes en leur nom. Si vos clÃ©s sont compromises, des acteurs malveillants pourraient les utiliser pour envoyer des requÃªtes aux endpoints X au nom de votre application dÃ©veloppeur ou de ses utilisateurs autorisÃ©s, ce qui pourrait vous amener Ã  atteindre des limites de dÃ©bit inattendues, Ã  Ã©puiser votre quota dâ€™accÃ¨s payant, voire Ã  entraÃ®ner la suspension de votre application dÃ©veloppeur.

Les sections suivantes prÃ©sentent des pratiques recommandÃ©es Ã  prendre en compte lors de la gestion de vos clÃ©s et jetons dâ€™API.

<div id="regenerate-api-keys-and-tokens">
  ## RÃ©gÃ©nÃ©rer des clÃ©s et des jetons dâ€™API
</div>

Si vous pensez que vos clÃ©s dâ€™API ont Ã©tÃ© exposÃ©es, vous devez les rÃ©gÃ©nÃ©rer en suivant ces Ã©tapes :

1. AccÃ©dez Ã  la [page Â« Projects and Apps Â» du portail dÃ©veloppeur](https://developer.x.com/en/portal/projects-and-apps.html).
2. Cliquez sur lâ€™icÃ´ne Â« Keys and tokens Â» (ğŸ—) Ã  cÃ´tÃ© de lâ€™application concernÃ©e.
3. Cliquez sur le bouton Â« Regenerate Â» Ã  cÃ´tÃ© de lâ€™ensemble de clÃ©s et de jetons que vous souhaitez rÃ©gÃ©nÃ©rer.

Si vous prÃ©fÃ©rez rÃ©gÃ©nÃ©rer vos Access Tokens ou Bearer Tokens par programmation, vous pouvez le faire en utilisant nos endpoints dâ€™authentification.

* Si vous souhaitez rÃ©gÃ©nÃ©rer vos Access Tokens, vous devez invalider vos jetons Ã  lâ€™aide de lâ€™endpoint [POST oauth/invalidate_token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), puis rÃ©gÃ©nÃ©rer vos jetons via le [flux OAuth en 3 Ã©tapes](/fr/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens).
* Si vous souhaitez rÃ©gÃ©nÃ©rer votre Bearer Token, vous devez invalider votre jeton Ã  lâ€™aide de lâ€™endpoint [POST oauth2/invalidate_token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), puis rÃ©gÃ©nÃ©rer votre jeton via lâ€™endpoint [POST oauth2/token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-token).

<div id="having-a-central-file-for-your-secrets">
  ## Disposer dâ€™un fichier central pour vos secrets
</div>

Utiliser un fichier comme .env ou un fichier .yaml pour stocker vos secrets peut Ãªtre utile, mais assurez-vous dâ€™avoir un fichier .gitignore solide afin dâ€™Ã©viter de les valider par inadvertance dans un dÃ©pÃ´t Git.Â 

<div id="environment-variables">
  ## Variables d'environnement
</div>

Ã‰crire du code qui utilise des variables d&#39;environnement peut Ãªtre utile.

En voici un exemple en PythonÂ :

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

Dans votre terminal, vous Ã©cririez quelque chose commeÂ :

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## Code source et gestion de versions
</div>

Les erreurs de sÃ©curitÃ© les plus courantes commises par les dÃ©veloppeurs consistent Ã  avoir des clÃ©s et des jetons dâ€™API commitÃ©s dans le code source au sein de systÃ¨mes de gestion de versions accessibles comme GitHub et Bitbucket. Nombre de ces dÃ©pÃ´ts de code sont publics. Cette erreur est si frÃ©quente dans les dÃ©pÃ´ts publics quâ€™il existe des bots lucratifs qui aspirent les clÃ©s dâ€™API.

* Utilisez des variables dâ€™environnement cÃ´tÃ© serveur. En stockant les clÃ©s dâ€™API dans des variables dâ€™environnement, vous les gardez hors de votre code et de la gestion de versions. Cela vous permet Ã©galement dâ€™utiliser facilement des clÃ©s diffÃ©rentes selon les environnements.
* Utilisez un fichier de configuration exclu du contrÃ´le de version. Ajoutez le nom du fichier Ã  votre fichier [.gitignore](https://git-scm.com/docs/gitignore) pour empÃªcher son suivi par la gestion de versions.
* Si vous retirez les clÃ©s dâ€™API de votre code aprÃ¨s avoir utilisÃ© la gestion de versions, il est probable quâ€™elles restent accessibles en consultant les versions prÃ©cÃ©dentes de votre base de code. RÃ©gÃ©nÃ©rez vos clÃ©s dâ€™API, comme dÃ©crit dans la section suivante.

<div id="databases">
  ## Bases de donnÃ©es
</div>

Si vous devez stocker vos jetons dâ€™accÃ¨s dans une base de donnÃ©es, tenez compte des points suivants :

* Restreignez lâ€™accÃ¨s Ã  la base de donnÃ©es de sorte que les jetons dâ€™accÃ¨s ne soient lisibles que par le propriÃ©taire du jeton.
* Limitez les droits de modification/Ã©criture sur la table dÃ©diÃ©e aux jetons dâ€™accÃ¨s â€” cela devrait Ãªtre automatisÃ© via le systÃ¨me de gestion des clÃ©s.
* Chiffrez les jetons dâ€™accÃ¨s avant de les stocker dans tout systÃ¨me de stockage de donnÃ©es.

<div id="password-management-tools">
  ## Outils de gestion des mots de passe
</div>

Les outils de gestion des mots de passe tels que 1Password ou LastPass peuvent Ãªtre utiles pour conserver vos clÃ©s et jetons en lieu sÃ»r. Vous pourriez toutefois Ã©viter de les partager dans un gestionnaire de mots de passe dâ€™Ã©quipe partagÃ©.

<div id="web-storage-cookies">
  ## Stockage web et cookies
</div>

Il existe deux types de stockage web : LocalStorage et SessionStorage. Ils ont Ã©tÃ© conÃ§us comme une amÃ©lioration par rapport aux cookies, car la capacitÃ© de stockage est bien supÃ©rieure Ã  celle des cookies. Chaque option prÃ©sente toutefois des avantages et des inconvÃ©nients distincts.
Â 

**Web Storage : LocalStorage**

Tout ce qui est stockÃ© dans le stockage web local est persistant. Autrement dit, les donnÃ©es restent en place jusquâ€™Ã  leur suppression explicite. Selon les besoins de votre projet, cela peut Ãªtre un atout. Toutefois, utilisez LocalStorage avec discernement, car toute modification ou tout ajout restera disponible lors de vos visites ultÃ©rieures de la page concernÃ©e. Nous ne recommandons gÃ©nÃ©ralement pas dâ€™utiliser LocalStorage, sauf cas particuliers. Si vous choisissez de lâ€™utiliser, notez quâ€™il respecte la politique de mÃªme origine : les donnÃ©es stockÃ©es ne sont accessibles quâ€™Ã  partir de la mÃªme origine. Un bÃ©nÃ©fice de performance associÃ© Ã  LocalStorage est la diminution du trafic client-serveur, puisque les donnÃ©es nâ€™ont pas Ã  Ãªtre renvoyÃ©es au serveur Ã  chaque requÃªte HTTP.
Â 

**Web Storage : SessionStorage**

SessionStorage est similaire Ã  LocalStorage, mais la diffÃ©rence clÃ© est quâ€™il nâ€™est pas persistant. Une fois la fenÃªtre (ou lâ€™onglet, selon le navigateur) utilisÃ©e pour Ã©crire dans SessionStorage fermÃ©e, les donnÃ©es sont perdues. Cela permet de restreindre lâ€™accÃ¨s en lecture Ã  votre jeton pendant une session utilisateur. En termes de sÃ©curitÃ©, SessionStorage est gÃ©nÃ©ralement prÃ©fÃ©rable Ã  LocalStorage. Comme pour LocalStorage, la prise en charge de la politique de mÃªme origine et la rÃ©duction du trafic client-serveur sâ€™appliquent Ã©galement Ã  SessionStorage.
Â 

**Cookies**

Les cookies sont la mÃ©thode traditionnelle pour stocker des donnÃ©es de session. Vous pouvez dÃ©finir une date dâ€™expiration pour chaque cookie, ce qui facilite la rÃ©vocation et la restriction dâ€™accÃ¨s. En revanche, le trafic client-serveur augmente avec les cookies, puisque les donnÃ©es sont renvoyÃ©es au serveur Ã  chaque requÃªte HTTP. Si vous utilisez des cookies, vous devez vous protÃ©ger contre le dÃ©tournement de session. Par dÃ©faut, les cookies sont envoyÃ©s en clair via HTTP, ce qui rend leur contenu vulnÃ©rable Ã  lâ€™Ã©coute de paquets et/ou aux attaques de type homme du milieu, oÃ¹ des attaquants peuvent modifier votre trafic. Vous devez toujours imposer HTTPS pour protÃ©ger vos donnÃ©es en transit. Cela assure la confidentialitÃ©, lâ€™intÃ©gritÃ© (des donnÃ©es) et lâ€™authentification. Toutefois, si votre application web ou votre site est accessible Ã  la fois en HTTP et en HTTPS, utilisez Ã©galement lâ€™attribut Â« Secure Â» sur le cookie. Cela empÃªchera des attaquants dâ€™envoyer Ã  un utilisateur des liens vers la version HTTP de votre site et dâ€™Ã©couter la requÃªte HTTP gÃ©nÃ©rÃ©e.
Â 
Une autre dÃ©fense complÃ©mentaire contre le dÃ©tournement de session lors de lâ€™utilisation de cookies consiste Ã  revÃ©rifier lâ€™identitÃ© de lâ€™utilisateur avant toute action Ã  fort impact. Un autre attribut Ã  envisager pour renforcer la sÃ©curitÃ© de vos cookies est Â« HttpOnly Â». Cet attribut indique au navigateur que le cookie concernÃ© ne doit Ãªtre accessible que par le serveur. Toute tentative dâ€™accÃ¨s par des scripts cÃ´tÃ© client sera interdite, ce qui aide Ã  se protÃ©ger contre la plupart des attaques de type cross-site scripting (XSS).