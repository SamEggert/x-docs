---
title: Pagination
sidebarTitle: Pagination
---

<div id="recent-search-pagination">
  ### Pagination de la recherche récente
</div>

<div id="introduction">
  #### Introduction
</div>

Les requêtes de recherche renvoient généralement plus de Posts qu’il n’est possible d’inclure dans une seule réponse d’API. Dans ce cas, les données sont renvoyées sous forme de « pages ». La pagination désigne les méthodes permettant de demander toutes les pages afin de récupérer l’ensemble du jeu de données.

Voici les principes fondamentaux de la pagination pour la recherche récente :

* Les endpoints de recherche récente répondent à une requête avec au moins une page et fournissent un next_token dans leur réponse JSON si des pages supplémentaires sont disponibles. Pour recevoir tous les Posts correspondants, répétez l’opération jusqu’à ce qu’aucun jeton ne soit inclus dans la réponse.

* Le next_token n’expire pas. Plusieurs requêtes utilisant la même valeur de next_token recevront les mêmes résultats, quel que soit le moment où la requête est effectuée.

* Les Posts sont renvoyés dans l’ordre antéchronologique, en fuseau horaire UTC. Cela vaut au sein de chaque page comme entre les pages :
  * Le premier Post de la première réponse sera le plus récent correspondant à votre requête.
  * Le dernier Post de la dernière réponse sera le plus ancien correspondant à votre requête.

* Le paramètre de requête max_results vous permet de configurer le nombre de Posts renvoyés par réponse. La valeur par défaut est 10 Posts et le maximum est 100.

* Toute implémentation de pagination implique d’extraire les next_tokens de la charge utile de la réponse et de les inclure dans la requête de recherche de « page suivante ». Voir ci-dessous pour plus de détails sur la construction de ces requêtes de « page suivante ».
   

L’endpoint de recherche récente a été conçu pour prendre en charge deux modes d’utilisation fondamentaux :

* **Récupérer l’historique** - Demander les Posts correspondant à une période donnée. Il s’agit généralement de requêtes ponctuelles pour des recherches historiques. Les requêtes de recherche peuvent utiliser les paramètres start_time et end_time. L’endpoint de recherche récente renvoie des Posts dans l’ordre antéchronologique, en commençant par le Post correspondant le plus récent.

* **Polling** - Demander les Posts correspondant à ceux publiés depuis le dernier Post reçu. Ces cas d’usage ont souvent un objectif quasi temps réel et se caractérisent par des requêtes fréquentes, « à l’écoute » de nouveaux Posts pertinents. L’endpoint de recherche récente fournit le paramètre since_id pour prendre en charge le mode « polling ». Pour faciliter la navigation par IDs de Post, le paramètre until_id est également disponible.
   

Nous aborderons ensuite le mode historique. Il s’agit du mode par défaut de l’endpoint de recherche récente et il illustre les principes fondamentaux de la pagination. Nous présenterons ensuite des exemples de cas d’usage de polling. Lorsque le polling déclenche la pagination, une étape supplémentaire est nécessaire pour gérer les requêtes de recherche.
 

<div id="retrieving-historical-data">
  #### Récupération de données historiques
</div>

Cette section explique comment récupérer des Posts sur une période donnée (actuellement limitée aux sept derniers jours) à l’aide des paramètres de requête start_time et end_time. Les requêtes historiques sont généralement ponctuelles et servent à la recherche et à l’analyse.

La récupération sur une période est le mode par défaut de l’endpoint recent search. Si une requête de recherche ne spécifie pas de paramètre start_time, end_time ou since_id, end_time prendra par défaut la valeur « maintenant » (en réalité 30 secondes avant l’heure de la requête) et start_time celle de sept jours plus tôt.

L’endpoint renverra la première « page » de Posts dans l’ordre antéchronologique, en commençant par le plus récent. Le payload JSON de la réponse inclura également un next_token s’il existe des pages supplémentaires. Pour collecter l’ensemble des Posts correspondants, quel que soit le nombre de pages, il faut poursuivre les requêtes jusqu’à ce qu’aucun next_token ne soit fourni.

Par exemple, voici une requête initiale pour des Posts contenant le mot-clé snow au cours de la dernière semaine :

https://api.x.com/2/tweets/search/recent?query=snow

La réponse inclut les 10 Posts les plus récents, ainsi que les attributs « meta » suivants dans la réponse JSON :

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

Pour récupérer les 10 Posts suivants, ajoutez ce next_token à la requête d’origine. La requête serait :

https://api.x.com/2/tweets/search/recent?query=snow&amp;next_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql

Le processus consistant à rechercher un next_token et à l’inclure dans une requête suivante peut être répété jusqu’à ce que tous (ou un certain nombre de) Posts aient été collectés, ou jusqu’à ce qu’un nombre spécifié de requêtes ait été atteint. Si la fidélité des données (collecter toutes les correspondances de votre requête) est essentielle pour votre cas d’usage, un simple mécanisme « répéter jusqu’à ce que request.next_token soit null » suffira. 
 

<div id="polling-and-listening-use-cases">
  #### Cas d’utilisation de polling et d’écoute
</div>

Cette section explique comment récupérer des Posts récents en interrogeant de façon répétée l’endpoint de recherche récente avec le paramètre de requête since_id.

Dans les cas d’usage de polling, des requêtes du type « de nouveaux Posts intéressants ? » sont exécutées en continu et à une fréquence élevée. Contrairement aux cas d’usage historiques, basés sur le temps, les cas d’usage de polling s’appuient généralement sur les IDs de Post.

Au cœur du modèle de polling se trouve le fait que chaque nouveau Post possède un [ID unique](/fr/resources/fundamentals/x-ids) qui est « émis » par la plateforme X, généralement dans l’ordre croissant. Si un Post a un ID inférieur à celui d’un autre, cela signifie qu’il a été publié plus tôt.

L’endpoint de recherche récente permet de parcourir l’archive des Posts par ID de Post. Les réponses de l’endpoint incluent les IDs de Post oldest_id et newest_id. En mode polling, les requêtes sont effectuées avec since_id défini sur l’ID le plus grand/le plus récent reçu jusqu’à présent.

Par exemple, supposons qu’une requête pour de nouveaux Posts sur la neige soit effectuée toutes les cinq minutes, et que le dernier Post reçu ait un ID de Post de 10000. Au moment d’interroger, la requête ressemble à ceci :

https://api.x.com/2/tweets/search/recent?query=snow&amp;since_id=10000

Ensuite, disons que sept Posts ont été publiés depuis notre dernière requête. Comme ils tiennent tous sur une seule « page » de données, il n’y a pas de next_token. La réponse fournit l’ID du Post le plus récent (newest) :

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

Pour effectuer la prochaine requête de polling, cette valeur newest_id est utilisée pour définir le prochain paramètre since_id :

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

Lorsqu’il y a plus de données disponibles et que des next tokens sont fournis, seule la valeur newest_id de la première page de résultats est nécessaire. Chaque page de données inclura des valeurs newest_id et oldest_id, mais la valeur fournie dans la première page est la seule requise pour la prochaine requête de polling, planifiée régulièrement. Ainsi, si vous implémentez un design de polling, ou recherchez des Posts par plage d’ID, la logique de pagination est légèrement plus complexe.

Supposons maintenant qu’il y ait 18 autres Posts correspondants. L’endpoint renverrait une première réponse avec une page de données complète et un next_token pour demander la page suivante de cette période de cinq minutes. Elle inclurait également l’ID du Post le plus récent nécessaire pour le prochain intervalle de polling dans cinq minutes.

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

Pour collecter toutes les données correspondantes pour cette période de cinq minutes, transmettez le next_token dans votre prochaine requête, avec la même valeur since_id que la requête précédente.

https://api.x.com/2/tweets/search/recent?query=snow&amp;since_id=12000&amp;next_token=fnsih9chihsnkjbsc

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

Cette deuxième réponse fournit les huit Posts restants, sans next_token. Notez que nous ne mettons pas à jour notre valeur newest_id (12300) et que nous basons plutôt notre prochain since_id sur la valeur newest_id de la première réponse :

https://api.x.com/2/tweets/search/recent?query=snow&amp;since_id=13800